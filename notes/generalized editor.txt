Heyo!

I'm been brainstorming for about 30 minutes after I had a nice idea seeing where I'm going with generalizations on the PixRay website, and your opinion on if I should put in the effort to implement this idea would be swell. =P

This is massive, and I apologize. It is also potentially very awesome.

All of the data going to/from the browser and the database is through a set of generalized api methods, such as "db.set" which will create new objects, or update existing ones, "db.get" which will retrieve all or part of a single object, or list of object, "db.delete", etc... Not at all like the RebelHouse where there is a news.update, menu.update_section, menu.update_item, etc.

I have then written a generalization around my jQuery editable plugin where I tell it what kind of object it is, and what key to save with. So I just call make_editable(obj, 'news', 'headline') and it hooks it all up.

I think even this is too much work on my part. If I go and design a set of naming conventions I can contain all of the information I need to make EVERYTHING dropped into a template from the database editable. For example, here is a theoretical news post:

<li class="db-news" id="db-news-12">
	<h2 class="db-news-headline">Mike has an idea!</h2>
	<h3 class="db-news-datetime">Wed, Feb 18, 2009</h3>
	<p class="db-news-body">
		Mike has come up with an idea...<br />
		He would like your thoughts about it!
	</p>
</li>

As you can see, the <li /> representing the post has a class that indicates it is a news item of the database. The id tells us that it is number 12. Then all the different parts of the post have a class that indicated what part of a news post they are.

It is then very easy to set all of these up to be editable with the default settings. But I don't WANT the default settings. The body should be an editable with nl2br awareness, and the datetime should pop open a calendar. So we put all of these specifications into a master JS file somehere:

$.register_db_editable('news.body', {
	type: 'text',
	options: {
		nl2br: true
	}
});
$.register_db_editable('news.datetime', {
	type: 'datetime'
	options: {
		// Whatever options there are for the datetime editor (which I need to write.)
	}
});

The headline is assumed to be a standard text editable with the default settings.

This is all very easy so far (I'm pretty much going to do this anyways) but the real ticket, I think, is the automatic creation of forms to create new objects in the database, and the automatic creation of markup that is the same as what the template would have done on the server side, and then injecting it into the right spot on the page!

My first idea is to create macros in the templates which would generate the markup representations... This is Jinja2 template syntax:

{% macro news(obj, class='') -%}
<li class="db-news{{ ' ' + class if class else '' }}" id="db-news-{{ obj.id }}">
	<h2 class="db-news-headline">{{ obj.headline|e }}</h2>
	<h3 class="db-news-datetime">{{ obj.datetime|format_date('date format here') }}</h3>
	<p class="db-news-body">{{ obj.body|e|nl2br }}</p>
</li>
{%- endmacro %}

I can then create the whole list of them in the template by:

<ol>
	{% for post in posts -%}
	{{ news(post) }}
	{%- endfor %}
<ol>

And THEN, if we are in the admin area, I can dump one more into the template for jQuery to work with:

{% if is_admin_area %}{{ news(None, 'template hide') }}{% endif -%}

Then I will get all of the markup, with no content, and it is hidden and marked as the template. The auto-generated form (which is another story) can then grab the template markup:

var post = $('.db-news.template').clone();

Once I learn more about OOP in javascript I can get a better idea about dynamically building classes to represent these objects, so you could go and:

// Make the post object.
var post = new Post({
	headline: 'Holy crap!'
	body: 'I am made dynamically!'
});

// Place it into the right spot on the page,
// as determined by some previously defined callbacks
// and the values of this object's attributes.
post.injectMarkup();

I think it might be able to get to the point where I have written wrapping classes around SQLAlchemy ORM classes so that we define our objects, what administrative permissions are required, api filtering mechanisms (to make non-text data transport safe, such as dates and other custom data), sorting callbacks, etc... and it builds up the javascript code required to represent all of the editability and transport code as well.

With that in place, the entirety of the Rebelhouse server-side would take a day.

Phew!



editables.register_type('show', {
    name: {
        type: 'text',
        multiline: false
    },
    date: {
        type: 'date'
    },
    status: {
        type: 'text',
        multiline: false
    body: {
        type: 'text',
        nl2br: true
    }
});

editables.form('show', callback) returns the basic form
    the form calls callback(obj) with obj being a new copy of the basic editables type (whatever that is =P)