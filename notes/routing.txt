===== general =====

I am trying too hard to make this do everything I could ever want. I can impose
some restrictions that will make things easier. The routers could not have
direct control over what remains unrouted, only how much gets popped off the
stack.

Also, we must allow routers to make the assumption that given the current state
of all data persistance, the routing stack upto the given router will route
exactly the same given the same input. Ie. there isnt a router below that is
routing randomly.
    - What about routing differently if logged in?
    - What about encoding the unrouted segment?
    - What about time-of-day differences?

normalizing unrouted:
    - assert we start with a slash
    - assert that there are no dot segments - does not match r'/\.\.?(/|$)'
    - throw a RouterInterfaceError if this happens
    - do NOT remove empty segments.

===== SelfRouter =====

class index(SelfRouter):
	
	def index(env, start):
		start(...)
		yield 'This is the index.'
	
	class inner(Router):
		
		def index(env, start):
			start(...)
			yield 'This is on the inside.'
		
		def _404(env, start):
			start(...)
			# this is for ones that aren't found.
		
		def _500(env, start):
			start(...)
			# this is for ones that error while going

/inner/index will go to the inner one


===== history =====

Everytime a router modifies the unrouted path we should store:
    before  - what the unrouted path was before routing
    after   - what the unrouted path is being set to
    router  - the router which did the routing (for unrouting and logging)
    unroute - optional - called to unroute this section
    args    - optional - passed to unrouter
    kwargs  - optional - passed to unrouter

How to build the same path from the routers:
    - if an unroute callback is supplied then it will be called with a new after
      segment, and supplied args/kwargs.
    - they would return what is to be unrouted before they run. this string
      should, when routed again by the same router, result in the same app
      running with the same history settings
    - the default will be to add the difference of before - after.
      ie. if a router got /a/b/c and put back /b/c originally, if they are
      handed /new to build on they return /a/new

To build a new path from a given router:
    - unroute_from(environ, router, unrouted) will rebuild from history at the
      first occourance of router assuming unrouted was unrouted at that point.
    - ReRouter can have a .build(environ, name_or_app, **kwargs) which builds
      whatever it needs to route to name_or_app, or using the new kwargs figures
      out which route to use. Then it calls on unroute_from(environ, self, unrouted)
      to finish the job


===== @accepts =====

- simple decorator to assert the request mode is one of the given.
- @accepts('get', 'post')
- don't need to deal with all or none

===== ReRouter =====

- Routes-like pattern matching.
- Can only match to segment boundaries

===== RawReRouter ===

- routes using full regexes
- still stuck to segment boundaries by the protocol
