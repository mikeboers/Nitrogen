
How the unrouted should be formated:
    - assert we start with a slash
    - assert that there are no dot segments - does not match r'/\.\.?(/|$)'
    - throw a RouterInterfaceError if this happens
    - do NOT remove empty segments.



===== History =====

Everytime a router modifies the unrouted path we should store:
    before  - What the unrouted path was before routing
    after   - What the unrouted path is being set to
    router  - The router which did the routing (for unrouting and logging)
    rebuild - Called to unroute this section. Optional.
				This is called with the unrouted path to build upon. It should 
				return the new unrouted path (usually the given unrouted with
				a prefix added.)

How to build the same path from the routers:
    - if a rebuild callback is supplied then it will be called with a new 
	  path segment
    - they would return what is to be unrouted before the router runs. this
      string should, when routed again by the same router, result in the same 
      app running with the same history settings (but this is not always going
      to be the case).
    - the default will be to add the difference of before - after.
      ie. if a router got /a/b/c and put back /b/c originally, if they are
      handed /new to build on they return /a/new

To build a new path from a given router:
    - unroute_from(environ, router, unrouted) will rebuild from history at the
      first occourance of router assuming unrouted was unrouted at that point.
    - ReRouter can have a .build(environ, name_or_app, **kwargs) which builds
      whatever it needs to route to name_or_app, or using the new kwargs figures
      out which route to use. Then it calls on unroute_from(environ, self, unrouted)
      to finish the job


===== @accepts =====

- simple decorator to assert the request mode is one of the given.
- @accepts('get', 'post')
- don't need to deal with all or none
