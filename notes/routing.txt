
How the unrouted should be formated:
    - assert we start with a slash
    - assert that there are no dot segments - does not match r'/\.\.?(/|$)'
    - throw a RouterInterfaceError if this happens
    - do NOT remove empty segments.



===== History =====

Everytime a router modifies the unrouted path we should store:
    before  - What the unrouted path was before routing
    after   - What the unrouted path is being set to
    router  - The router which did the routing (for unrouting and logging)
    rebuild - Called to unroute this section. Optional.
				This is called with the unrouted path to build upon. It should 
				return the new unrouted path (usually the given unrouted with
				a prefix added.)

How to build the same path from the routers:
    - if a rebuild callback is supplied then it will be called with a new 
	  path segment
    - they would return what is to be unrouted before the router runs. this
      string should, when routed again by the same router, result in the same 
      app running with the same history settings (but this is not always going
      to be the case).
    - the default will be to add the difference of before - after.
      ie. if a router got /a/b/c and put back /b/c originally, if they are
      handed /new to build on they return /a/new

To build a new path from a given router:
    - unroute_from(environ, router, unrouted) will rebuild from history at the
      first occourance of router assuming unrouted was unrouted at that point.
    - ReRouter can have a .build(environ, name_or_app, **kwargs) which builds
      whatever it needs to route to name_or_app, or using the new kwargs figures
      out which route to use. Then it calls on unroute_from(environ, self, unrouted)
      to finish the job


===== @accepts =====

- simple decorator to assert the request mode is one of the given.
- @accepts('get', 'post')
- don't need to deal with all or none


===== new scheme =====


`Route` is the class the manages the whole route. It is essentially a list of one or more chunks. The chunks keep track of what part of the originally requested path remains unrouted. The first route chunk contains the original
requested path.

`RouteChunk` is an individual part of the route.

The process of constructing a URL moving backwards along a route is called "generating".

Starting with a request to "/controller/action/id"
	1) a ModuleRouter pulls off the "controller" and launches controller.__app__.
	2) a ReRouter matches /action/{id:\d+} and runs whatever app is registered.
	
	There are three chunks of route history:
		1) "/controller/action/id"
		2) "/action/id"
		3) "" with data {'id': whatever}
	
As long as there is a segment left to route, the unrouted will be non-empty. So a unrouted "/" would indicate that there is an empty segment to route.

With the setup how it currently is, there really is not way to have a global url_for-like function. You can specify data for the individual chunks, but then you have to have foreknowledge of it. Must figure out a way to have url_for pass its keyword arguments down the chain to slowly be consumed
	ModuleRouter could have a url_for_key which determines what it should pop
	out of the kwargs

a RouteChunk will proxy __getitem__ and __getattr__ to the data object if they
have one

a Route will proxy __getitem__ and __getattr__ to the last route segment

url_for will have the signature:
	def url_for(route_name=None, **args, **kwargs)
		the data gets updated with everything from args, then kwargs, then
		route_name is set to route_name. then this data object is passed up
		the chain

RouteChunk.generate(unrouted, data=None, one=False)

