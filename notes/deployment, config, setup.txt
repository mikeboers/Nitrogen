
Absolutely NOTHING should ever happen when you import nitrogen, or any of the
modules therein. NOTHING. The setup/config should be done by some bootstrapper
that is explicitly setup by the application. Explicit is better than implicit.
    - loggers can be setup by this bootstrapper, as driven by a installation
      specific config file.

Every module should be as seperate from each other as possible.

==============================================================================
BOOTSTRAPPING and SETUP
==============================================================================

models:
    - the nitrogen models should (be able to) depend on the app engine/session
    - the nitrogen.models.meta could be updated by the app.models.meta to
      be the same. use the same setup of metadata modules with
      initializers in both nitrogen and the app. the app can init the
      framework ones as well.
    - everything would then pull on meta.engine and meta.whatever
    - everything should (by convention) always access stuff from the meta
      module via attribute access, and not store anything locally. this
      would allow for the metadata to change as is nessesary
    - the individual model classes could either have their own metadata like
      this, or be built by functions which take an engine or session (or
      whatever they actually depend on)

views:
    - same basic setup as the models:
        - meta.path (the list used by the loader), meta.load, meta.render,
          meta.render_string, etc
    - a list of callbacks that modify the template context before it is
      rendered allow for the adding of request specific data. this could maybe
      be global, or thread-local, or whatever.




the session/render/config could all be stored in a lib/config/meta/global module
    - this module can could have a function that bootstraps itself
    - it would contain a global engine, thread-local session, metadata,
      template lookup/render, etc and application is more than free to make
      more for it's own uses
    - try to have functions availible to build similar functionality as the
      global ones, and those are what are used to build the global ones
    - paste stores this in the model.meta module. This seems apt
    - could store view globals in a views.meta module (maybe)
    - need a Session.remove() for the thread-local session after the request
      is done processing

new plan:
    - there should be no global setup at all. classes should define the environment of everything
    - an app or bootstrap module can hook everything together for an app so that the app doesnt have to know much
    - the environments can have their own logger with the name __name__?env=<name of environment>
    - should I go with env, environ, or environment
    - the textblobs could be in their own module which has functions to hook it into a model_environ and template_environ

