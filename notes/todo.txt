

- route.Chain should catch status exceptions and start_response(status, ...) as
  well.
    - status should have a function to throw a given status code. Do this by
      having the function that defines all of the status exceptions store them
      into a module-global dict. The thrower can then just look it up and throw
      it.
    - if the status given to start_response is one that the Chain is supposed to
      catch (this should be configurable, but default to 404) then throw the
      corresponding exception which is caught by the normal machinery
    - all the caught statuses should be logged by the chain
    - MAYBE we want to have the ability to save the state of the routing history
      so that the chain can restore it before trying another app
        - save_history() could return the state of the history (maybe just the
          length of the list), and restore_history(state) will put it back the
          same as it was at the time of the save call.

- Compare the lib/markdown with lib/webhelpers/markdown
    - I think the webhelpers one has references and line breaks, while the other
      does not.
    - The webhelpers one also looks a bit easier to extend.
    - Make line breaks drop in <br />




- Api model editable access should be a WSGI app class. It will be acceable through
  /news/model/add or what have you.

- See about getting https working.

- Compress all of the javascript and css files together with minify (or write
my own minifier, which sounds like a bad idea).
    - css doesn't need compression if it is coming from sass
    - Shane said to look at sprockets (it is in ruby)

- as_request should be a class with __get__ so that it knows when to inject a
    self at the front

- decide if the cookie container should default to the path being '/'

- write a Mailer class using the sendmail functions. write a MailLogger to go with it
    - use the rfc822 address functions/classes to handle addresses

- rename the nitrogen.logs.FileLogger to something that indicates it is time based

- make sure that the Makefile does everything the setup script did

- deploy scripts need to work again

- not_found_catcher -> status.status_notifier
    - takes a dict mapping status to template to throw
    - a traceback parameter determines if it should dump a traceback with env
      and everything

- logs should be timestamping with utc time, not local time

- the (Raw)ReRouter(s) should take a second parameter which, if supplied, is
  the replacement string that will be used as the unrouted after this router
  is done.
    - Can maybe do some crazy logic with the ReRouter to provide a reverse path as well.

- it might be a good idea to write my own pickling sockets instead of using
  the Listener and Client from multiprocessing.connection
    - Then I can have more standard symantics about when the socket is closed, and such

- daemon class
    - The massive PyPi library: http://pypi.python.org/pypi/python-daemon/
    - Pretty clean daemon implementation here: http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/

    - The second one in general looks a lot nicer to work work, but needs to
      be extended to be smarter about the pid file, possibly using some
      filelocks (that I have written, not using the filelock module)

- move headers into http package? or pull everything back out of http package.

- admin gateway should work again

- model_adapter should work again

- editables should work again

- write a session

- consider having default log path include the thread-id as well so that they are running into seperate files

- textblobs should have an environ object just like models and views
	- the javascript to make them go should also be in the markup

