
- model and view contexts could be callable wsgi middleware themselves,
  instead of having a WSGI reset.
 
- use repoze instead of my own auth stuff
    - light wrapper around the authorizor to move 'repoze.who.identity' somewhere
      else so that we can have multiple classes of user
    - looks like I can use repoze.who fairly easily, but repoze.what is going
      to be a bit nastier
    - perhaps I still have to write my own user permission/groups code, but
      dont have to do any of the authentication low-level stuff

- webio functions should actually be in funcions and not just middleware
  you pass them an environment, they do their stuff, and cache the results in
  the environ. the second time they just return cached results
  the middleware simply uses these functions. perhaps another function will
  store it in the same place as paste does so it is easily picked up by repoz.what.Precicate.get_form_vars

- think about rewriting route storage to work with wsgi.routing_args spec
    http://www.wsgi.org/wsgi/Specifications/routing_args
    
    - I don't think I'll actually be able to do this fully, but I can place my
      results in here as well as in my place

- rewrite route specs to use SCRIPT_NAME and PATH_INFO as expected.
  

- bottle (http://bottle.paws.de/) has an interesting idea where they have a 
  view decorator which injects whatever was returned from the controller into
  the template view.
  
      @view('some_template.mako')
      @as_request
      def something(req, res):
        # blah blah blah
        return {'key':'value'}

- small wsgi app that serves files. you can ive it a filename and a root. it
  will normalize the filename and do proper cache headers and so forth
        
        return StaticFileHandler(filename, root='/path/to/files', maxage=600)(req.environ, res.start)

- consider using redis as key-value store instead of bucket

- the caching middleware should only be giving a 304 Not Modified if the status
  was already 200.

- editables should be renamed. maybe ajaxcrud

- editables should roughly follow the Atom publishing protocl. see what pylons
  does: http://wiki.pylonshq.com/display/pylonscookbook/How+map.resource+enables+controllers+as+services

- routes packages should try to import the HTTPNotFound exception to use as a
  base for the Unroutable exception, in addition to ValueError or
  something. Then if nitrogen is installed then it will be catchable as a 404.

- need a general status catcher middleware. status exceptions could have a
  body which could then be passed by the status catcher. if there is no body
  then we would log this and then throw a 500.

- rerouters need a _methods key which takes acceptable methods. ie:
    @router.register(_method='POST') or _method=('PUT', 'DELETE')
    This MUST understand the _method query param, but only accept not GET/HEAD
    methods if it is actually a post. Ie you can't have a ?_method=PUT on a
    GET, only a POST. We have it in the query string so that we don't trigger
    the file parsing at this point.

- the objects returns from routing api methods should be a named tuple
- consider renaming route.tools to route.base

- api MUST not just pull in all the get and post data, for that will trigger
  file parsing. It can look in the get and post data when you ask it to, but
  do NOT do it automatically or without provocation.
  
  - ApiRequest could perform lookups into get/post/cookies and then raise an
    extended KeyError which would be understoon by te ApiResponse

- need to either bulk up the encoder or replace it with something else.
	- IE does not supply a Accept-Charset header, but it still does accept
	  UTF-8.
	- Should only be auto encoding stuff for text/* content types.

- paste webob.Request is completely malleable. this is so you can modify the
  request and pass it on to someone else. This seems like a Good Thingâ„¢.

- route.Transformer could exist solely to manipulate the data that is getting
  passed around. Then one can pass in a model and have the url generated for
  it specifically


- figure out which parts can be seperated out
	- flickr
		- "milkr" is NOT taken on pypi
	- uri
		- "uri" is taken on pypi
		- "uritools", "urilib
		

	- route
		- "router"
		- "wsgi-router"
        
- mailer does wierd things with unicode email addresses


- route.Chain should catch status exceptions and start_response(status, ...) as
  well.
    - status should have a function to throw a given status code. Do this by
      having the function that defines all of the status exceptions store them
      into a module-global dict. The thrower can then just look it up and throw
      it.
    - if the status given to start_response is one that the Chain is supposed to
      catch (this should be configurable, but default to 404) then throw the
      corresponding exception which is caught by the normal machinery
    - all the caught statuses should be logged by the chain
    - MAYBE we want to have the ability to save the state of the routing history
      so that the chain can restore it before trying another app
        - save_history() could return the state of the history (maybe just the
          length of the list), and restore_history(state) will put it back the
          same as it was at the time of the save call.

- Compare the lib/markdown with lib/webhelpers/markdown
    - I think the webhelpers one has references and line breaks, while the other
      does not.
    - The webhelpers one also looks a bit easier to extend.
    - Make line breaks drop in <br />


- would be swell if the route generation could be a little smarter. for the
  swissol product pages I would like to only pass a product model, and i
  would figure out that I want controller='products' and whatever the collection is.


- See about getting https working.

- Compress all of the javascript and css files together with minify (or write
my own minifier, which sounds like a bad idea).
    - css doesn't need compression if it is coming from sass
    - Shane said to look at sprockets (it is in ruby)

- as_request should be a class with __get__ so that it knows when to inject a
  self at the front. Also because the current method of detecting if it is
  a method will fail if exc_info is passed in as well (just looking for 3
  positional arguments).

- decide if the cookie container should default to the path being '/'

- write a Mailer class using the sendmail functions. write a MailLogger to go with it
    - use the rfc822 address functions/classes to handle addresses

- rename the nitrogen.logs.FileLogger to something that indicates it is time based

- make sure that the Makefile does everything the setup script did

- deploy scripts need to work again

- not_found_catcher -> status.status_notifier
    - takes a dict mapping status to template to throw
    - a traceback parameter determines if it should dump a traceback with env
      and everything

- logs should be timestamping with utc time, not local time

- the (Raw)ReRouter(s) should take a second parameter which, if supplied, is
  the replacement string that will be used as the unrouted after this router
  is done.
    - Can maybe do some crazy logic with the ReRouter to provide a reverse path as well.

- it might be a good idea to write my own pickling sockets instead of using
  the Listener and Client from multiprocessing.connection
    - Then I can have more standard symantics about when the socket is closed, and such

- daemon class
    - The massive PyPi library: http://pypi.python.org/pypi/python-daemon/
    - Pretty clean daemon implementation here: http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/

    - The second one in general looks a lot nicer to work work, but needs to
      be extended to be smarter about the pid file, possibly using some
      filelocks (that I have written, not using the filelock module)

- move headers into http package? or pull everything back out of http package.

- admin gateway should work again

- model_adapter should work again

- editables should work again

- write a session

- consider having default log path include the thread-id as well so that they are running into seperate files

- textblobs should have an environ object just like models and views

- hash IPs in the logs, so we dont store actual IPs. need to salt them or do something else fancy
	maybe hash together a salt, ip, user-agent, and anything else that is constant from that user

- the setup_logging middleware should not be added automatically by the runners
	it is not that special

- file logger should put the format string through `time.strftime(format.replace('%(', '%%')), time.gmtime()) % params`
  to get the file name (also so it is in GMT). actually need to double the number of percent signs in except for those that precede a single letter

- multiple processes logging to the same file is not safe. the docs seems to suggest
  that the multiprocessing module could be handy in writing a new file handler

- see if I can make a daemonize function out of multiprocessing, so that the locks still work
	they are semaphores, which are based on file descriptors. so just dont kill them all!


- route history objects should proxy item access to the data object
	should have some more properties (prev -> previous piece of history, next,
	first, last, is_first, is_last, rebuild -> rebuilds this routeing chunk,
	rebuild_route builds the full route back to the beginning... or from one
	router to another

- pull out a bunch of todo itesm from http://www.catonmat.net/blog/50-ideas-for-the-new-catonmat-website/?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+catonmat+%28good+coders+code%2C+great+reuse%29&utm_content=Google+Reader 
  as it has some good ideas

- user.context
	- allow username, realname, or email to be used as password
	- many different ways to authenticate: password, PPP, yubikey, email token
	  ' token, sms, openid, etc
	- the login/authentication page should see that I am coming from 127.0.0.1
	  and allow me to create a new user, or use a temporary superuser
	- users should not need to be backed by the database, so that we can have
	  a guest user (if we decide that we want one) and other temporary users
	  (the temp superuser for local connections).
	- middleware to make sure that a user is authenticated to get to the
	  requested url. maybe have it check what the url is... or have some other
	  middleware (more general) that runs these tests and optinally skips the
	  next piece of middleware. so it goes through the authenticator if the
	  domain starts with "admin." or something.
	- permissions should be heirarchical split with /. maybe so something with
	  absolute vs relative ones

	- groups
		- can contain users, or other groups
		- can have permissions
	
	django user model:
		- is_staff: the user can access the admin site
		- is_active: all has_perm(...) calls will return False, no matter the
		  permissions
		- is_superuser: all has_perm(...) calls will return True, no matter the
		  permissions
		- last_login: last time they logged in
		- date_created: datetime when they were created
		- is_anonymous(): always returns false for users. They seem to put in
		  a dummy AnonymousUser if someone is not logged in
		- is_authenticated(): has the user authenticated (in this session)? In
		  django this will always return True.
		- set_password(...)
		- check_password(...)
		- get_group_permissions(): a list of permissions obtained through membership
		- get_all_permissions(): a list of all permissions
		- has_perm(...): Do they have the permissions? For django they are
		  of the format "<app label>.<permission codename>".
		- has_perms(...): Do they have all the specified permissions?
		- get_profile(): Returns the site-sepcific profile... Whatever that means.
	
	django user management:
		- create_user(username, email, password=None)
		- make_random_password(length=10, charset='...')
		- login_required(app): a decorator which forwards you to the login page
		  it takes a "redirect_field_name" parameter which determines the get
		  key for where to redirect after login
		- the login page is "/accounts/login" by default
	
	ideas of mine while reading django stuff
		- sendmail(...): Send them an email.
		- is_in_group(<groupname>): is_staff() is really just is_in_group('/staff')
		- trigger_password_reset(): Send an email with a password reset link.
		- Manager.authenticate(username, password): returns a user if it was
		  valid. more likely this would also take: yubicode, ppp_token, ...
		  This does NOT login the user; just authenticates them
		- User.login() does the actual login using whatever persistance method
		  has been chosed by the manager. It may take the request/response as
		  an argument.
		- User.logout(). It may take request/response as arguement. Should
		  completely destroy any session that was setup for the user.

		- should an anonymous user be an object, or None?
			- with an object, we only have to do one test (has_perm) instead
			  of two (user and user.has_perm). it seems like if we design the
			  apps securely, we will always be checking permissions anyways
			- with an object, if the user is not in the view context it is an
			  error. with None, you never really know for sure. It is one less
			  point of failure to expect it to be an object
		- perhaps a manage.py script which is hooked into the app configuration
		  is a good idea. it can be what sets permissions, adds superusers,
		  edits config files, etc
		- need not have admin subdomain. one can just go to /admin, and if you
		  are in "admin mode" or not is just a flag in your session.
		- if we keep using the same admin_gateway middleware (which enforces a
		  login on all admin subdomain pages), then some other middleware could
		  make an app not require that gateway to run. maybe. this would likely
		  require all middleware to use a @middleware decorator which does some
		  magic with metadata and such, and I don't really want to do that.
		- @user_needs_perm('permission') requires a user to have a permission
		  before they can go on. or @perm_required('perm')
		- the resolution order of groups should be similar to the MRO for classes.
		  because we expect to have a multiple inheritance structure, this is
		  required
		- it would be nice if the permissions we tested for were actual objects.
		  then it would be relatively easy to go about populating a view with
		  ALL of the possible permissions.
	
	- other django stuff:
		- user is always an object in the view context
		- perms is an object for testing for permission by proxying to the user
		  ie perms.admin would be True if they had '/admin', perms.admin.whatever
		  would be true for /admin/whatever'. make it callable for checking
		  patterns: perms('/admin/*/something?k=v')


	- cookies should be read-only on the request, and read-write on the response
		But does this REALLY make a whole lot of sense? They could be read-write
		on BOTH (the same object, actually).
	
	- change the url parameter on the login page that redirects to "next":
		/login/?next=whereveryouwere . It also need not be url encoded. The query
		should know that it does not need to encode slashes (by default); only
		# and ?.
	
	- @as_request can allow you to return HTTP status exceptions and it would
	  throw them for you. But why bother?
	
	- can formalchemy set 'enctype="multipart/form-data"' on the form?
	
	- can we get access to the reported content_type of the file that is being
	  posted? perhaps the charset as well?
	
	- maybe extend the file upload protocol so that there is a function for
	  write, and a function for the upload being done, and maybe the constructor
	  gets the expected length and content type and so forth as well.
	  http://docs.djangoproject.com/en/1.1/topics/http/file-uploads/#topics-http-file-uploads
		
- MapRouter should sort keys by length before trying to match.
- ModuleMapRouter could map prefixes to module names to import: "app.controller.news.main"
  could run "main" of "app.controller.news". This just seems kinda lazy on my
  part though

- consider having the 3 routing protocol methods return dicts instead of tuples.
  it would make the code easier to read:
	return dict(path=newpath, child=app, data={})

- redirectors
	mappings of paths (or path regexes) to map from/to with a http status code
	(301?) and a location header

- the App object can have mail_admins(...) that proxies sendmail to whomever
  are specified as admins for the app (either in the config or the database?)

	- mail_managers(...) or mail_group(groupname, ...)
	- the From address should be automatically added. no-reply@domain.com
	- the subject could have a prefix attached
	- they could take only a subject and a message:
		app.mail_admins('Help!', 'Something has exploded!')

- the django mailers only check for newlines '\r' or '\n' in addresses, not for
  something that completely parses properly.

- django conditional view processing is pretty neat. a condition(etag_func=None, last_modified_func=None)
  returns a decorator that will use the passed functions (which are given only
  the request object) to see if the etag matches or the last_modified matches.
  then it can send whatever headers it wants or calls the app. this is only
  suggested (by me) if these calculations are very lightweight.

	- @check_etag and @check_last_modified would both be for just one of the two
	- you dont want to chain them though, as perhaps one would be true and the
	  other false, and you want them BOTH to be true...

- django has an intersting idea with a set_test_cookie() on the session. it
  sets a test cookie. you can check for it with test_cookie_worked() and del
  with delete_test_cookie(). You set the test cookie when displaying a login
  form, and check for it when someone posts credentials back. you reject them
  if they have not set cookies yet.
  http://docs.djangoproject.com/en/1.1/topics/http/sessions/#module-django.contrib.sessions

- django has a "sites" framework, to allow it to power more than one site with
  the same code. I should try to make my App (or Site) class work in a way so
  that several of them can play nicely beside each other. can import a site
  config out of a configs folder (example_com.py or admin_example_com.py), or
  perhaps run the domain through a mapping to determin which config to use
  (so that admin.example.com uses the same config as example.com).

- We no longer have a need for the admin sub-domain. Simply track if they are
  logged in via the session. can even add a login link into the footer for the
  client to use

- get a lorem-ipsum generator into the main template context



- read about the Atom publishing protocol, and the set of REST URLs that go with it
  it seems the Pylons uses that setup a bunch (for resources in the route mapper
  http://pylonshq.com/docs/en/0.9.7/thirdparty/routes/#routes.base.Mapper.resource )

- Response.matches() and Response.not_modified() would call start with the right
  headers

- FieldSet class should be called FieldSet, not Form. form module should be at
  nitrogen.form, not nitrogen.form

- consider breaking various parts of nitrogen into different packages.
	- they would assemble into the same namespace using what magic module does that...
	- use pip to install them with --no-install option to just build them
	- then softlink them into the site-packages

- in place editors:
	- take all the options out of the email I sent shane
	- consider http://usabilitythoughts.com/edit-in-place.html
	- research other usability issues
	- http://www.digital-web.com/articles/usability_for_rich_internet_applications/






beta and stage should have a whitelist to allow entry. that whitelist should
be able to be added to from the web with a password or by visiting some signed URL
	
	whitelist
	checkpoint
	sentinel
	guard
	gatekeeper
	doorkeeper
	monitor
	sentry

Figure out a better naming scheme for the functions that are WSGI middleware.
The are called middleware by their function, but the function that does the
actual wrapping is not middleware. Ideas:

	- LogFormatter.wsgi_setup(app)

go through route notes
decide if I want the route object to have item access to the data, or if that
is on route.data
	if the second, does the request object .route refer to the route, or the data
	is the data a dict, or a multimap?
	
	seems like the Request will be mainly using data, and nothing else will
	the Request should build up a dictionary for it's own uses. the route need
	not do it

get new permissions script in place


FieldSet._render should take a multipart=True param which allows for file uploads.
	that should be passed into the viewenviron.render call, and the template
	set enctype="multipart/form-data"


some class/function to manage request throttling. once configured, calling the
function will simply delay for a certain amount of time. should be able to be
tied to both the IP, and all activity in general.

start designing an App class which loads a config, sets up a model/view/
textblob environ, and generally manages the interactions bettween all the
parts of a site. This should be a part of nitrogen.

standardize on a primary middleware wrapping function which does all the
wrapping. Several wrappers will handle discrete types: one for error logging
and reporting, one for managing http (encoding, etagging), one to put them
all together

- the various contexts should not bother with having their own log and name
  unless they absolutely need it
- the UserContext should have a table_prefix, instead of "name"

- What should I name all these environs?
	- "model_environ":
		+ makes sense
		- hard to type
		. "model_env" short form
	- "model_context":
		+ pretty easy to type
		. "model_ctx" short form
	- "model_domain":
		+ really easy to type
		- no good short form
	
	context: the set of circumstances or facts that surround a particular
		event, situation, etc.
	environ: the aggregate of surrounding things, conditions, or influences
	domain: a realm or range of personal knowledge, responsibility, etc.

- ViewContent
	render should take pre_path and post_path to search before and after the
	main path. should be able to make a new render function which remembers
	these things. should be able to continuously wrap these things
	
- Crud
	manage both the api side of the crud operations (like the editables now)
	and provide standard web based stuff. lists of objects, getting objects,
	updating and deleting, ect.
	
	permission_base gets appended to to figure out all the permissions

- locals
	make a local object factory which keeps a reference to the __dict__ so that
	it can be cleared out on every request by some middleware

- flash_messages
	- be able to persist them so that we can specify a flash message to show up
	in the next response
	
- users
	- should not be able to verify an email if you are already logged in
	- should automatically login when a password is set for the first time


- nitrogen.app.Basic
    - setup the basic stuff for running an app automagically
        logs, routing, ect
    - nitrogn.app.Basic.from_config(module=config)
    - the server objects can be greatly simplified, or just replaced with a
      hostname and install path ("//host/path")
    - the config object can be an actual class that has every config option
      as a property (or something). this could simply be the whole application
      class.

- password hashing
    use either scrypt or PBKDF2 (http://www.daemonology.net/blog/2009-06-11-cryptographic-right-answers.html)

- use this openid selector http://code.google.com/p/openid-selector/

- use my own tomcrypt library
	- password hashing
	- encrypted cookies

- make sure i'm not doing any of http://googletesting.blogspot.com/2008/07/how-to-write-3v1l-untestable-code.html

- pull in http://www.mechanicalcat.net/richard/log/Python/Simple__elegant_HTML_generation