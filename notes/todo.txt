

- route.Chain should catch status exceptions and start_response(status, ...) as
  well.
    - status should have a function to throw a given status code. Do this by
      having the function that defines all of the status exceptions store them
      into a module-global dict. The thrower can then just look it up and throw
      it.
    - if the status given to start_response is one that the Chain is supposed to
      catch (this should be configurable, but default to 404) then throw the
      corresponding exception which is caught by the normal machinery
    - all the caught statuses should be logged by the chain
    - MAYBE we want to have the ability to save the state of the routing history
      so that the chain can restore it before trying another app
        - save_history() could return the state of the history (maybe just the
          length of the list), and restore_history(state) will put it back the
          same as it was at the time of the save call.

- Compare the lib/markdown with lib/webhelpers/markdown
    - I think the webhelpers one has references and line breaks, while the other
      does not.
    - The webhelpers one also looks a bit easier to extend.
    - Make line breaks drop in <br />




- Api model editable access should be a WSGI app class. It will be acceable through
  /news/model/add or what have you.

- See about getting https working.

- Compress all of the javascript and css files together with minify (or write
my own minifier, which sounds like a bad idea).
    - css doesn't need compression if it is coming from sass
    - Shane said to look at sprockets (it is in ruby)

- as_request should be a class with __get__ so that it knows when to inject a
    self at the front

- decide if the cookie container should default to the path being '/'

- write a Mailer class using the sendmail functions. write a MailLogger to go with it
    - use the rfc822 address functions/classes to handle addresses

- rename the nitrogen.logs.FileLogger to something that indicates it is time based

- make sure that the Makefile does everything the setup script did

- deploy scripts need to work again

- not_found_catcher -> status.status_notifier
    - takes a dict mapping status to template to throw
    - a traceback parameter determines if it should dump a traceback with env
      and everything

- logs should be timestamping with utc time, not local time

- the (Raw)ReRouter(s) should take a second parameter which, if supplied, is
  the replacement string that will be used as the unrouted after this router
  is done.
    - Can maybe do some crazy logic with the ReRouter to provide a reverse path as well.

- it might be a good idea to write my own pickling sockets instead of using
  the Listener and Client from multiprocessing.connection
    - Then I can have more standard symantics about when the socket is closed, and such

- daemon class
    - The massive PyPi library: http://pypi.python.org/pypi/python-daemon/
    - Pretty clean daemon implementation here: http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/

    - The second one in general looks a lot nicer to work work, but needs to
      be extended to be smarter about the pid file, possibly using some
      filelocks (that I have written, not using the filelock module)

- move headers into http package? or pull everything back out of http package.

- admin gateway should work again

- model_adapter should work again

- editables should work again

- write a session

- consider having default log path include the thread-id as well so that they are running into seperate files

- textblobs should have an environ object just like models and views

- hash IPs in the logs, so we dont store actual IPs. need to salt them or do something else fancy
	maybe hash together a salt, ip, user-agent, and anything else that is constant from that user

- the setup_logging middleware should not be added automatically by the runners
	it is not that special

- file logger should put the format string through `time.strftime(format.replace('%(', '%%')), time.gmtime()) % params`
  to get the file name (also so it is in GMT). actually need to double the number of percent signs in except for those that precede a single letter

- multiple processes logging to the same file is not safe. the docs seems to suggest
  that the multiprocessing module could be handy in writing a new file handler

- see if I can make a daemonize function out of multiprocessing, so that the locks still work
	they are semaphores, which are based on file descriptors. so just dont kill them all!

- see if I can sendmail from the command line on this machine, and the vps
	if I can, then make a Sendmail class which uses this instead of SMTP like the Mailer
	
	- I can sendmail from the VPS. It doesnt need anything fancier than:
		sendmail mail@example.com
		this is a test
		^D
	
	port 25 is blocked by teksavvy. they should remove it upon request

- route history objects should proxy item access to the data object
	should have some more properties (prev -> previous piece of history, next,
	first, last, is_first, is_last, rebuild -> rebuilds this routeing chunk,
	rebuild_route builds the full route back to the beginning... or from one
	router to another

	
)

