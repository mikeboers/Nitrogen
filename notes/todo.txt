

RANDOM/NEW
==========

- consider switching to werkzeug's exceptions
	- only if we stop using beaker for sessions... cause beaker requires paste

- the debug flag should only ever mean to turn on debugging (ie. logging
  exceptino reporting, and interactive debugger)

- consider doing what werkzeug does with it's request objects:

    @Request.application
    def application(request):
        return Response("Hello %s!" % request.args.get('name', 'World!'))

	Response is actually a wsgi application; if it has some content set and
	you return the value of calling it then all the proper headers (ie, an etag
	will be set)
	
	So now what actually keeps me from using werkzeug Request/Response?
	Why does the request have to see the response, anyways?
		- cookie config
		
	could use request.reponse.headers to set headers
	could yield (200, <headers>) and then body pieces
	could return Request(content, code=whatever, headers=whatever)

- nitrogen.App
		
	- replaces the view_context
		- app.flash(message, category)
			these get appended to 'app.flash_messages' in the current session
			app.get_flashed_messages returns that list and clears it out
	
	- setup up sessions automatically
	
	- incorporates the logging
	
	- app.wsgi_app is the actual wsgi app that gets called. One can wrap this
	  at will. It is likely in our interests to have two sets of middleware
	  stacks, as the compressor should come really really late in the game
		- low level: (app.wsgi_init)
			compressor
			encoder (utf8 encoder)
			one level of error catching/handling
			model/view local reset (this is replaced anyways)
			global local reset
		- high level: (app.wsgi_app)
			prep_view_context
			catch_status_exceptions
			cookie.setup_factory
			authentication (this can be added by an application)
	
	- app.run() defaults to serving it with a socket (this is app.config.run_mode = 'socket')
		app.run(mode='fcgi')
	
	- app.shell() provides some command-line integration
		but for what?
		perhaps running migrate
	
	- app.init_request(environ)
		does all the very low level stuff
	- app.handle_request(environ, start)
		does the high level (application level) stuff
	
	- app.setup() is called automatically when .run is called. it also calls
	  all the other setup functions (logging, db, view). this can be done either
	  with a list of functions (app.setup_functions) or with an even system
	  (things respond to 'nitrogen.setup' event with no args)
	
	- app.config is an extension of a dict
		- config.from_object will pull all attribute that do not start with '_'
	
	- text blobs are actually a mixin!
		- registers it's own MapRouter
		- adds to the app.view_globals
	
	- make it incredibly extensible:
		- textblobs are an extension (respond to __textblob)
			register __textblob in the master MapRouter
			they have their own template path
				within that path they are 'ext-textblob/textblob.html'
			they serve the javascript files themselves
				use FileRouter, which just serves files from a directory
				lift the stuff behind this directly from flask
		- session is an extension
		- imgsizer
			register _imgsizer in the master MapRouter
			use werkzeug.is_resource_modified just for the last_modified header
		
		- all of these are classes that extend AppCore and use super properly
	
	- somehow need to be able to specify cookies to set/delete before the
	  container is set, because that will come from the environ["nitrogen.cookie.build_header"]
		- app will have it's own Response and Request classes; perhaps we could
		  extend those to know what cookie_factory we want to use
			app.cookie_factory could be a method which uses app.config['private_key']
			
			app.request_class = Request.build_class('AppRequest', cookie_factory=self.cookie_factory)
				@classmethod
				CommonCore.build_class(cls, name, extra_bases=(), **dict):
					return type(name, (cls, ) + extra_bases, dict)
			app.response_class = Response.build_class(cookie_factory=self.cookie_factory)
	
	
	nitrogen.core contains imports to all these fun things:
		- App from nitrogen.app
		- abort raises an exception, from http.status
		- redirect raises a redicrection exception
	
	- app.export_onto(__import__(__name__))
		- exports a LOT of the properties into modulespace
		
	
	

- see if I really have to add an IP and such to logs on my own: perhaps
  the logs that I pipe into apache stderr get that sort of thing added on
- look really closely at flask
    I can roughly approximate everything that flask is going by having a
    nitrogen.app.App class which wraps together all the db/template/config
    stuff
    
    If I want my framework to be as easy to start using, then I will have to
    have sensible defaults for everything.
    
        from nitrogen import App
        app = App(__name__)
        
        @app.route('/')
        def index(req, res):
            return 'Hello, world!'
    
    How much do I really need to keep holding onto WSGI? There are only a couple
    cases that I really need to keep going that way: repoze.who and repoze.what
        

- nitrogen.route.ReRouter could have some builtin types:
    @router.register(r'/photos/{photo_id}')
    this could make sure that photo_id matches r'\d+', and gets casted to/from
    an integer





- Replace my textarea plugin with http://plugins.jquery.com/project/a-tools

- Consider replacing my attrdata plugin with http://plugins.jquery.com/project/customdata

- Turn some modules into their own projects:
	- flickr
	- imgsizer
	- mail as "easymailer"
	- route as "pystar"
	- uri as "uri"

- etagger should only work if the iterable is not an iterator (ie. not an instance of collections.Iterator)

- request.unrouted should work even if nothing was routed

- request.user_agent should never be None (it is coming from PayPal IPN)
- Consider using alternate WSGI setup where the app must return a 3-tuple of
  (status, headers, iterable). It seems the thing I would actually lose from
  this would be the write function which gets returned from the start_callback
  (which I have never actually used, and would break horribly if I used it).

  It should be pretty easy to adapt from one style to the other:
	
		import collections
		import itertools

		def newstyle_to_old(app):
		    def oldstyle(environ, start):
		        status, headers, content = app(environ)
		        start(status, headers)
		        return content
		    return oldstyle

		def _warn_on_write(*args):
		    raise DeprecationWarning('newstyle WSGI does not have a write method')

		def oldstyle_to_newstyle(app):
		    def newstyle_app(environ):
		        state = []
		        def start(status, headers, exc_info=None):
		            state[:] = (status, headers)
		            return _warn_on_write
		        content = list(app(environ, start))
		        return state[0], state[1], content
		    return newstyle_app

		def anystyle_to_newstyle(app):
		    if app.func_code.co_argcount > 1:
		        return oldstyle_to_newstyle(app)
		    return app
		
  Id you want to do some streaming then you will need to use the newstyle or
  write a a custom translator which is more forgiving about when start is
  called.

  Could use app.func_code.co_argcount to determine if it is a newstyle or
  oldstyle WSGI app. Then a wsgi.call(app, environ) function could exist that
  is smart about the calling style of the app and gives you back newstyle
  parameters

- route Request properties could be provided by a route.RequestMixin

- Consider never allowing Request.cache_control to be None; the parameters of
  the object will all be None, but the object itself will always exist.

- Write action throttler; when called it sleeps for an amount of time to make
  sure we don't pass it any faster than we should be allowed to.

  It needs to work off of both non-spoofable things, and client side. Key by
  the IP, and the class B and C network (to differing amounts, obviously).
  Also by a cookie that is sent to the client (this one most strongly).

  It has either a sleep method or a get_delay method or a test method
  
  see: http://stackoverflow.com/questions/549/the-definitive-guide-to-website-authentication-beta#477585
    should implement several different methods from here, as they all have their
    own place
  
  the short_sleep(max_delay) method will sleep if less than max_delay, or throw
  an exception (which we can then turn into a server error)

- Consider forcing ReRouter defaults to be provided in a defaults kwarg, and
  then parsers, formatters, etc, need not have "_" prefix anymore.

- Write middleware to set HTTP "Server" response header to:
	"'; DROP TABLE servertypes; --"

is there any way for the app to know if the browser has killed the connection?
    This could be handy for very long delays of the throttler

WSGI BEST PRACTISES
===================

Really need to STOP buffering output. Part of the specification
(http://www.python.org/dev/peps/pep-0333/#buffering-and-streaming) states that
middleware must always forward the entire block it receives to it's parent
gateway/server.

    - middleware which is fine:
        compressor
        log_formatter
        error_logger
        utf8_encoder
        model/view_context setup
        cookies.setup_factory
        prep_view_context
        auth.wrap... I'm not sure
        not_found_catcher
        routers
    - middleware which is NOT fine:
        output_buffer
        error_notifier
		etagger

If I assure that I will only call start_response once, then I can likely do
this






REQUEST LOCAL OBJECTS
=====================

MAYBE set up a global werkzeug local manager as middleware to register against. Perhaps this is automatically done by the servers

It may be a better idea in general to have each object which uses a local object clear out its local object itself...

What needs to use this mechanism?
    - loggers need to pull IP and such from the environ
    - view context needs to clear out flash messages
    - model context needs to destroy the context session

VIEW CONTEXT and TEMPLATE PATHs
===============================

I want to write my own Mako loader so that it is trivially easy for me to
modify the path.

The various ways I could do this are:
    - a bare bones class which only has the minimal API
    - extend the current loader and override the path property.
    - the path property of the view context can manipulate the loader

The loader (which may well be the entire view context) should have a copy method which returns us another loader/context with the same values. Then we can proceed to modify paths and defaults, etc.


HEIRARCHICAL HTTP SIGNALS, STATUSES and ERRORS
==============================================


- the signal_converter middleware should be very very closet to the top of the
  stack.
    - store the exception in 'nitrogen.http.signal.caught'
- middleware which turns exceptions into HTTPServerError (or whatever, via a
  mapping, maybe) and raises them. 
- middleware logs all of the non-http exceptions
- middleware converts non-http exceptions into a 500 internal server error
    - this one will need to attach the original exception so that I can get
      a traceback to the client for debug servers. could pass the causing
      exception as the detail. (Python 3 would nicely remove the need for
      doing this manually.)
    - OR, this can use the exact same function that the next middleware does
      and simply feeds in a 500 "Internal Server Error" with the detail saying
      that an unknown error has occoured, and to please try again.
- other middleware does the actual reporting

- exception catcher should first try to catch HttpExceptions, and then grab
  everything. the non-HttpException should be turned into a ServerError with
  a traceback iff the server is in debug mode
  
  
RANDOM IDEAS
============




- "Dear valued user,

    You have found the error page for the error page...
    You win!!

"


- Request.peek_path_info() and pop_path_info() (for routers, so they don't have to use the full uri.path.Path)



- multimap._conform_value could take both the key AND the value.
    
- either bring in the bucket or make it it's own project
- bring in PyTomCrypt (try to get it to compile with just the setup)

- try to design a class for generic middleware which respects the intricacies
  of the 3rd parameter to start. perhaps design it as a class with methods to
  overide.
  
  - it would allow you to restart until the first real content was sent down
    the pipe
  - i dont really understand how to fail gracefully with an exception...

- the exception catcher should buffer the whole request, and reset it every
  time a start is called which passes on exc_info
  - this would require all my middleware to use it properly...

- remove the magic from nitrogen.model.__init__

- model and view contexts could be callable wsgi middleware themselves,
  instead of having a WSGI reset.

- use repoze instead of my own auth stuff
    - light wrapper around the authorizor to move 'repoze.who.identity' somewhere
      else so that we can have multiple classes of user
    - looks like I can use repoze.who fairly easily, but repoze.what is going
      to be a bit nastier
    - perhaps I still have to write my own user permission/groups code, but
      dont have to do any of the authentication low-level stuff

  

- bottle (http://bottle.paws.de/) has an interesting idea where they have a 
  view decorator which injects whatever was returned from the controller into
  the template view.
  
      @view('some_template.mako')
      @as_request
      def something(req, res):
        # blah blah blah
        return {'key':'value'}

- small wsgi app that serves files. you can ive it a filename and a root. it
  will normalize the filename and do proper cache headers and so forth
        
        return StaticFileHandler(filename, root='/path/to/files', maxage=600)(req.environ, res.start)

- consider using redis as key-value store instead of bucket


- editables should be renamed. maybe ajaxcrud, or nitrogen.model.crud.CRUD

- editables should roughly follow the Atom publishing protocl. see what pylons
  does: http://wiki.pylonshq.com/display/pylonscookbook/How+map.resource+enables+controllers+as+services



- api MUST not just pull in all the get and post data, for that will trigger
  file parsing. It can look in the get and post data when you ask it to, but
  do NOT do it automatically or without provocation.
  
  - ApiRequest could perform lookups into get/post/cookies and then raise an
    extended KeyError which would be understoon by te ApiResponse

- need to either bulk up the encoder or replace it with something else.
	- IE does not supply a Accept-Charset header, but it still does accept
	  UTF-8.
	- Should only be auto encoding stuff for text/* content types.


- route.Transformer could exist solely to manipulate the data that is getting
  passed around. Then one can pass in a model and have the url generated for
  it specifically


- figure out which parts can be seperated out
	- flickr
		- "milkr" is NOT taken on pypi
	- uri
		- "uri" is taken on pypi
		- "uritools", "urilib
		

	- route
		- "router"
		- "wsgi-router"
        
- mailer does wierd things with unicode email addresses


- route.Chain should catch status exceptions and start_response(status, ...) as
  well.
    - status should have a function to throw a given status code. Do this by
      having the function that defines all of the status exceptions store them
      into a module-global dict. The thrower can then just look it up and throw
      it.
    - if the status given to start_response is one that the Chain is supposed to
      catch (this should be configurable, but default to 404) then throw the
      corresponding exception which is caught by the normal machinery
    - all the caught statuses should be logged by the chain
    - MAYBE we want to have the ability to save the state of the routing history
      so that the chain can restore it before trying another app
        - save_history() could return the state of the history (maybe just the
          length of the list), and restore_history(state) will put it back the
          same as it was at the time of the save call.

- Compare the lib/markdown with lib/webhelpers/markdown
    - I think the webhelpers one has references and line breaks, while the other
      does not.
    - The webhelpers one also looks a bit easier to extend.
    - Make line breaks drop in <br />

- See about getting https working.

- Compress all of the javascript and css files together with minify (or write
my own minifier, which sounds like a bad idea).
    - css doesn't need compression if it is coming from sass
    - Shane said to look at sprockets (it is in ruby)


- rename the nitrogen.logs.FileLogger to something that indicates it is time based

- not_found_catcher -> status.status_notifier
    - takes a dict mapping status to template to throw
    - a traceback parameter determines if it should dump a traceback with env
      and everything

- logs should be timestamping with utc time, not local time


- it might be a good idea to write my own pickling sockets instead of using
  the Listener and Client from multiprocessing.connection
    - Then I can have more standard symantics about when the socket is closed, and such




- model_adapter should work again

- editables should work again

- write a session

- consider having default log path include the thread-id as well so that they are running into seperate files

- textblobs should have an environ object just like models and views

- hash IPs in the logs, so we dont store actual IPs. need to salt them or do something else fancy
	maybe hash together a salt, ip, user-agent, and anything else that is constant from that user

- the setup_logging middleware should not be added automatically by the runners
	it is not that special

- file logger should put the format string through `time.strftime(format.replace('%(', '%%')), time.gmtime()) % params`
  to get the file name (also so it is in GMT). actually need to double the number of percent signs in except for those that precede a single letter

- multiple processes logging to the same file is not safe. the docs seems to suggest
  that the multiprocessing module could be handy in writing a new file handler

- route history objects should proxy item access to the data object
	should have some more properties (prev -> previous piece of history, next,
	first, last, is_first, is_last, rebuild -> rebuilds this routeing chunk,
	rebuild_route builds the full route back to the beginning... or from one
	router to another

- pull out a bunch of todo itesm from http://www.catonmat.net/blog/50-ideas-for-the-new-catonmat-website/?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+catonmat+%28good+coders+code%2C+great+reuse%29&utm_content=Google+Reader 
  as it has some good ideas

- user.context
	- allow username, realname, or email to be used as password
	- many different ways to authenticate: password, PPP, yubikey, email token
	  ' token, sms, openid, etc
	- the login/authentication page should see that I am coming from 127.0.0.1
	  and allow me to create a new user, or use a temporary superuser
	- users should not need to be backed by the database, so that we can have
	  a guest user (if we decide that we want one) and other temporary users
	  (the temp superuser for local connections).
	- middleware to make sure that a user is authenticated to get to the
	  requested url. maybe have it check what the url is... or have some other
	  middleware (more general) that runs these tests and optinally skips the
	  next piece of middleware. so it goes through the authenticator if the
	  domain starts with "admin." or something.
	- permissions should be heirarchical split with /. maybe so something with
	  absolute vs relative ones

	- groups
		- can contain users, or other groups
		- can have permissions
	
	django user model:
		- is_staff: the user can access the admin site
		- is_active: all has_perm(...) calls will return False, no matter the
		  permissions
		- is_superuser: all has_perm(...) calls will return True, no matter the
		  permissions
		- last_login: last time they logged in
		- date_created: datetime when they were created
		- is_anonymous(): always returns false for users. They seem to put in
		  a dummy AnonymousUser if someone is not logged in
		- is_authenticated(): has the user authenticated (in this session)? In
		  django this will always return True.
		- set_password(...)
		- check_password(...)
		- get_group_permissions(): a list of permissions obtained through membership
		- get_all_permissions(): a list of all permissions
		- has_perm(...): Do they have the permissions? For django they are
		  of the format "<app label>.<permission codename>".
		- has_perms(...): Do they have all the specified permissions?
		- get_profile(): Returns the site-sepcific profile... Whatever that means.
	
	django user management:
		- create_user(username, email, password=None)
		- make_random_password(length=10, charset='...')
		- login_required(app): a decorator which forwards you to the login page
		  it takes a "redirect_field_name" parameter which determines the get
		  key for where to redirect after login
		- the login page is "/accounts/login" by default
	
	ideas of mine while reading django stuff
		- sendmail(...): Send them an email.
		- is_in_group(<groupname>): is_staff() is really just is_in_group('/staff')
		- trigger_password_reset(): Send an email with a password reset link.
		- Manager.authenticate(username, password): returns a user if it was
		  valid. more likely this would also take: yubicode, ppp_token, ...
		  This does NOT login the user; just authenticates them
		- User.login() does the actual login using whatever persistance method
		  has been chosed by the manager. It may take the request/response as
		  an argument.
		- User.logout(). It may take request/response as arguement. Should
		  completely destroy any session that was setup for the user.

		- should an anonymous user be an object, or None?
			- with an object, we only have to do one test (has_perm) instead
			  of two (user and user.has_perm). it seems like if we design the
			  apps securely, we will always be checking permissions anyways
			- with an object, if the user is not in the view context it is an
			  error. with None, you never really know for sure. It is one less
			  point of failure to expect it to be an object
		- perhaps a manage.py script which is hooked into the app configuration
		  is a good idea. it can be what sets permissions, adds superusers,
		  edits config files, etc
		- need not have admin subdomain. one can just go to /admin, and if you
		  are in "admin mode" or not is just a flag in your session.
		- if we keep using the same admin_gateway middleware (which enforces a
		  login on all admin subdomain pages), then some other middleware could
		  make an app not require that gateway to run. maybe. this would likely
		  require all middleware to use a @middleware decorator which does some
		  magic with metadata and such, and I don't really want to do that.
		- @user_needs_perm('permission') requires a user to have a permission
		  before they can go on. or @perm_required('perm')
		- the resolution order of groups should be similar to the MRO for classes.
		  because we expect to have a multiple inheritance structure, this is
		  required
		- it would be nice if the permissions we tested for were actual objects.
		  then it would be relatively easy to go about populating a view with
		  ALL of the possible permissions.
	
	- other django stuff:
		- user is always an object in the view context
		- perms is an object for testing for permission by proxying to the user
		  ie perms.admin would be True if they had '/admin', perms.admin.whatever
		  would be true for /admin/whatever'. make it callable for checking
		  patterns: perms('/admin/*/something?k=v')



	
	- change the url parameter on the login page that redirects to "next":
		/login/?next=whereveryouwere . It also need not be url encoded. The query
		should know that it does not need to encode slashes (by default); only
		# and ?.
	
	- @as_request can allow you to return HTTP status exceptions and it would
	  throw them for you. But why bother?
	
	- can formalchemy set 'enctype="multipart/form-data"' on the form?
	
	- can we get access to the reported content_type of the file that is being
	  posted? perhaps the charset as well?
	
	- maybe extend the file upload protocol so that there is a function for
	  write, and a function for the upload being done, and maybe the constructor
	  gets the expected length and content type and so forth as well.
	  http://docs.djangoproject.com/en/1.1/topics/http/file-uploads/#topics-http-file-uploads
		
- MapRouter should sort keys by length before trying to match.
- ModuleMapRouter could map prefixes to module names to import: "app.controller.news.main"
  could run "main" of "app.controller.news". This just seems kinda lazy on my
  part though



- redirectors
	mappings of paths (or path regexes) to map from/to with a http status code
	(301?) and a location header

- the App object can have mail_admins(...) that proxies sendmail to whomever
  are specified as admins for the app (either in the config or the database?)

	- mail_managers(...) or mail_group(groupname, ...)
	- the From address should be automatically added. no-reply@domain.com
	- the subject could have a prefix attached
	- they could take only a subject and a message:
		app.mail_admins('Help!', 'Something has exploded!')

- the django mailers only check for newlines '\r' or '\n' in addresses, not for
  something that completely parses properly.

- django conditional view processing is pretty neat. a condition(etag_func=None, last_modified_func=None)
  returns a decorator that will use the passed functions (which are given only
  the request object) to see if the etag matches or the last_modified matches.
  then it can send whatever headers it wants or calls the app. this is only
  suggested (by me) if these calculations are very lightweight.

	- @check_etag and @check_last_modified would both be for just one of the two
	- you dont want to chain them though, as perhaps one would be true and the
	  other false, and you want them BOTH to be true...

- django has an intersting idea with a set_test_cookie() on the session. it
  sets a test cookie. you can check for it with test_cookie_worked() and del
  with delete_test_cookie(). You set the test cookie when displaying a login
  form, and check for it when someone posts credentials back. you reject them
  if they have not set cookies yet.
  http://docs.djangoproject.com/en/1.1/topics/http/sessions/#module-django.contrib.sessions

- django has a "sites" framework, to allow it to power more than one site with
  the same code. I should try to make my App (or Site) class work in a way so
  that several of them can play nicely beside each other. can import a site
  config out of a configs folder (example_com.py or admin_example_com.py), or
  perhaps run the domain through a mapping to determin which config to use
  (so that admin.example.com uses the same config as example.com).

- We no longer have a need for the admin sub-domain. Simply track if they are
  logged in via the session. can even add a login link into the footer for the
  client to use


- read about the Atom publishing protocol, and the set of REST URLs that go with it
  it seems the Pylons uses that setup a bunch (for resources in the route mapper
  http://pylonshq.com/docs/en/0.9.7/thirdparty/routes/#routes.base.Mapper.resource )

- Response.matches() and Response.not_modified() would call start with the right
  headers

- FieldSet class should be called FieldSet, not Form. form module should be at
  nitrogen.form, not nitrogen.form

- consider breaking various parts of nitrogen into different packages.
	- they would assemble into the same namespace using what magic module does that...
	- use pip to install them with --no-install option to just build them
	- then softlink them into the site-packages

- in place editors:
	- take all the options out of the email I sent shane
	- consider http://usabilitythoughts.com/edit-in-place.html
	- research other usability issues
	- http://www.digital-web.com/articles/usability_for_rich_internet_applications/






beta and stage should have a whitelist to allow entry. that whitelist should
be able to be added to from the web with a password or by visiting some signed URL
	
	whitelist
	checkpoint
	sentinel
	guard
	gatekeeper
	doorkeeper
	monitor
	sentry



FieldSet._render should take a multipart=True param which allows for file uploads.
	that should be passed into the viewenviron.render call, and the template
	set enctype="multipart/form-data"


start designing an App class which loads a config, sets up a model/view/
textblob environ, and generally manages the interactions bettween all the
parts of a site. This should be a part of nitrogen.

standardize on a primary middleware wrapping function which does all the
wrapping. Several wrappers will handle discrete types: one for error logging
and reporting, one for managing http (encoding, etagging), one to put them
all together

- the various contexts should not bother with having their own log and name
  unless they absolutely need it
- the UserContext should have a table_prefix, instead of "name"


	
- Crud
	manage both the api side of the crud operations (like the editables now)
	and provide standard web based stuff. lists of objects, getting objects,
	updating and deleting, ect.
	
	permission_base gets appended to to figure out all the permissions

- locals
	make a local object factory which keeps a reference to the __dict__ so that
	it can be cleared out on every request by some middleware

- flash_messages
	- be able to persist them so that we can specify a flash message to show up
	in the next response
	
- users
	- should not be able to verify an email if you are already logged in
	- should automatically login when a password is set for the first time


- nitrogen.app.Basic
    - setup the basic stuff for running an app automagically
        logs, routing, ect
    - nitrogn.app.Basic.from_config(module=config)
    - the server objects can be greatly simplified, or just replaced with a
      hostname and install path ("//host/path")
    - the config object can be an actual class that has every config option
      as a property (or something). this could simply be the whole application
      class.

- password hashing
    use either scrypt or PBKDF2 (http://www.daemonology.net/blog/2009-06-11-cryptographic-right-answers.html)

- use this openid selector http://code.google.com/p/openid-selector/

- use my own tomcrypt library
	- password hashing
	- encrypted cookies

- make sure i'm not doing any of http://googletesting.blogspot.com/2008/07/how-to-write-3v1l-untestable-code.html

- pull in http://www.mechanicalcat.net/richard/log/Python/Simple__elegant_HTML_generation