
- wtforms date and datetime should use input type="date"
  - same with email
- wtforms should be able to have placeholders


- asset specification -> "package.name:file_name.txt"

- remove serve extensions (just write your own...)
- remove api
	- add Request.assert_args(*names) -> throws an exception if it doesn't have them
	- rewrite CRUD
- remove pager
- rename forms to wtforms

- remove most of crypto (replaced by pytomcrypt)

- move mako stuff into nitrogen.templates.mako.helpers


- @renderer(html='/path/to/template')
	- requesting something.json would give us the JSON dump
	- requesting something.html would give us the rendered page
	- anything else would default to the rendered page


- some way to convert data to json format if requested, otherwise actually
  render everything. Will need to be sure that there aren't any secret things
  being passed to the templates...

- upgrade to Werkzeug 0.7

- werkzeug tracks all of the amounts posted, we dont need to at request.py:143
	I think we may still need to.

- constructive things to do
	- plugin architecture and/or namespaces for app plugins

- FileMutator
	- a couple of methods to override to have a file served that is built from
	  another. the results will be cached

- versioned_static_url('/path/to/asset')
	- makes a '/t=<mtime-of-file>/path/to/asset?v=<mtime-of-file>'
	- these should be served with a HUGE cache time

- nitrogen.sign
	- sign(secret, str_to_sign, **kwargs) -> signature
	- verify(secret, str_to_sign, signature, **kwargs) -> bool
	
	- either use a deterministic repr or only allow strings to be signed


- nitrogen.lock.FileLock
	__init__(path, mode='shared', recursive=False)
	acquire
	locked
	release
	upgrade -> convert shared to exclusive
	downgrade -> convert exclusive to shared






- consider moving Cookie signing code into the cookies themselves, and the
  container has a list of classes to use to try to parse the raw values

- new session	
	- __ctime__, __atime__, __mtime__ in the dict
	- .lock(name='__main__', shared=False) method creates a /<root>/<id>.<name>.lock file and returns it
	- .purge/.reset/.clear/.save methods
	- the dict must detect mutations
	- save by writing to /<root>/<name>.<random>.journal and moving into place
		this avoids a race condition



- instead of naming app mixin classes ResponseMixin, perhaps have a decorator
which marks something as a mixin.
	
	@mixin('Response')
	class ResponseMixin(object):
		pass


- replace webhelpers with lxml

- Authnz package could provide a router object which tests ACLs
- authn is extracting principals (uid and gid) from a request
- authz is determining if principals are ALLOWed or DENYied by an __acl__
- Pyramid authn_policy interface only supplies:
    - unauthenticated_userid(self, request)
    - remember(self, request, principal, **kw)
    - forget(self, request)

- should the things that AppMixins export be namespaced? Instead of exporting
  everything they could export a single object such as "db" with all the DB
  stuff

- AppPlugin instead of AppMixin
	- use c3linearize to determine proper ordering of plugins


- Pyramid renderers are rather nice.
    @Request.application # or @Request.wrap
    @renderer('template.html.mako') # run through MakoRenderer and then HTMLRenderer (which sets the mimetype)
    def something(req):
        return {'key': 'value'}

- asset specification is nice: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/assets.html#asset-specifications

- consider moving to an events-like notification system for the before_request and after_request sort of callbacks.

- use this new linearizer for the building of classes out of mixins on the AppMixins

- take a good hard look at some sort of plugin architechture or the ZCA (Zope Component Architecture) instead of multiple inheritance for linking all of the App pieces together.
    - where there are dependencies, the individual plugins can define what they need, and what they use
    - the c3linearize could be used to figure out an assembly order of these
    - the plugin api should be as minimal as possible:
        - method to return list of middleware
        - method to return dict of what should be exported to globals
        - method to setup configuration defaults
        
- have to look really hard at the "context" resource that Pyramid is always talking about.

- consider putting the full python virtualenv into an env subdirectory in all of the sites. This may make everything a little bit more self contained and easier to work in.

- take a look at how pyramid tests itself

- API error handler is not printing out the environment of the request. Can we possibly extend logging to add this to the exception method, or perhaps add a wsgi_exception method?

- pull the mixin class builder into a package of its own?

- pkgutil: figure out how to split up the project
    1) namespaced_packages=[...] (i think) in setup.py. this may only be nessesary
       for installed packages, but may not be nesseary at all
    2) __import__('pkg_resources').declare_namespace(__name__) in all the
       __init__.py that are namespaced
    2-b) Could potentially use the pkgutil one as well:
        __path__ = __import__('pkgutil').extend_path(__path__, __name__)
        
    

- instead of using submodules I could have a pip requirements file that is
  only going off of the "editing" modules. `make freeze-subs` could


      
