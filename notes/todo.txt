

- route.Chain should catch status exceptions and start_response(status, ...) as
  well.
    - status should have a function to throw a given status code. Do this by
      having the function that defines all of the status exceptions store them
      into a module-global dict. The thrower can then just look it up and throw
      it.
    - if the status given to start_response is one that the Chain is supposed to
      catch (this should be configurable, but default to 404) then throw the
      corresponding exception which is caught by the normal machinery
    - all the caught statuses should be logged by the chain
    - MAYBE we want to have the ability to save the state of the routing history
      so that the chain can restore it before trying another app
        - save_history() could return the state of the history (maybe just the
          length of the list), and restore_history(state) will put it back the
          same as it was at the time of the save call.

- Compare the lib/markdown with lib/webhelpers/markdown
    - I think the webhelpers one has references and line breaks, while the other
      does not.
    - The webhelpers one also looks a bit easier to extend.
    - Make line breaks drop in <br />




- Api model editable access should be a WSGI app class. It will be acceable through
  /news/model/add or what have you.

- See about getting https working.

- Compress all of the javascript and css files together with minify (or write
my own minifier, which sounds like a bad idea).
    - css doesn't need compression if it is coming from sass
    - Shane said to look at sprockets (it is in ruby)

- as_request should be a class with __get__ so that it knows when to inject a
    self at the front

- decide if the cookie container should default to the path being '/'

- write a Mailer class using the sendmail functions. write a MailLogger to go with it
    - use the rfc822 address functions/classes to handle addresses

- rename the nitrogen.logs.FileLogger to something that indicates it is time based

- make sure that the Makefile does everything the setup script did

- deploy scripts need to work again

- not_found_catcher -> status.status_notifier
    - takes a dict mapping status to template to throw
    - a traceback parameter determines if it should dump a traceback with env
      and everything

- logs should be timestamping with utc time, not local time

- the (Raw)ReRouter(s) should take a second parameter which, if supplied, is
  the replacement string that will be used as the unrouted after this router
  is done.
    - Can maybe do some crazy logic with the ReRouter to provide a reverse path as well.

- it might be a good idea to write my own pickling sockets instead of using
  the Listener and Client from multiprocessing.connection
    - Then I can have more standard symantics about when the socket is closed, and such

- daemon class
    - The massive PyPi library: http://pypi.python.org/pypi/python-daemon/
    - Pretty clean daemon implementation here: http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/

    - The second one in general looks a lot nicer to work work, but needs to
      be extended to be smarter about the pid file, possibly using some
      filelocks (that I have written, not using the filelock module)

- move headers into http package? or pull everything back out of http package.

- admin gateway should work again

- model_adapter should work again

- editables should work again

- write a session

- consider having default log path include the thread-id as well so that they are running into seperate files

- textblobs should have an environ object just like models and views

- hash IPs in the logs, so we dont store actual IPs. need to salt them or do something else fancy
	maybe hash together a salt, ip, user-agent, and anything else that is constant from that user

- the setup_logging middleware should not be added automatically by the runners
	it is not that special

- file logger should put the format string through `time.strftime(format.replace('%(', '%%')), time.gmtime()) % params`
  to get the file name (also so it is in GMT). actually need to double the number of percent signs in except for those that precede a single letter

- multiple processes logging to the same file is not safe. the docs seems to suggest
  that the multiprocessing module could be handy in writing a new file handler

- see if I can make a daemonize function out of multiprocessing, so that the locks still work
	they are semaphores, which are based on file descriptors. so just dont kill them all!


- route history objects should proxy item access to the data object
	should have some more properties (prev -> previous piece of history, next,
	first, last, is_first, is_last, rebuild -> rebuilds this routeing chunk,
	rebuild_route builds the full route back to the beginning... or from one
	router to another

- all the wsgi inner functions should be named such as:
	ModelEnviron__clear_after_request__wsgi_app with the classname and method and everything

- pull out a bunch of todo itesm from http://www.catonmat.net/blog/50-ideas-for-the-new-catonmat-website/?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+catonmat+%28good+coders+code%2C+great+reuse%29&utm_content=Google+Reader 
  as it has some good ideas

- user environ
	- allow username, realname, or email to be used as password
	- many different ways to authenticate: password, PPP, yubikey, email token
	  prowl token, sms, openid, etc
	- the login/authentication page should see that I am coming from 127.0.0.1
	  and allow me to create a new user, or use a temporary superuser
	- users should not need to be backed by the database, so that we can have
	  a guest user (if we decide that we want one) and other temporary users
	  (the temp superuser for local connections).
	- middleware to make sure that a user is authenticated to get to the
	  requested url. maybe have it check what the url is... or have some other
	  middleware (more general) that runs these tests and optinally skips the
	  next piece of middleware. so it goes through the authenticator if the
	  domain starts with "admin." or something.
	- permissions should be heirarchical split with /. maybe so something with
	  absolute vs relative ones

- redirectors
	mappings of paths (or path regexes) to map from/to with a http status code
	(301?) and a location header


- consider breaking various parts of nitrogen into different packages.
	- they would assemble into the same namespace using what magic module does that...
	- use pip to install them with --no-install option to just build them
	- then softlink them into the site-packages

- in place editors:
	- take all the options out of the email I sent shane
	- consider http://usabilitythoughts.com/edit-in-place.html
	- research other usability issues
	- http://www.digital-web.com/articles/usability_for_rich_internet_applications/

- some sort of SASS like meta language for specifying attributes of markup?
	You have one layer of HAML for the markup itself, another layer for adding
	classes and names and attributes to the markup itself, and another layer
	of the css.
	
	Have it have python-like indentation, be haml like, and use markdown type
	syntax for inline stuff.
	
	call it pyml (PYthon Markup Language)
		#id
			%p{'key': 'value', **attributes, (k, v) for something in data}
				This is some content.
				%strong
					with inline strength
				and
				%em
					inline emphasis
				.
				
				A full blank line specifies that it should be a seperate
				paragraph, but only if it is in a p block.
			%
				! if test():
					some stuff in the test. you break out again by dropping out
					of the if. the only nasty part is that we couldn't start
					a tag in one block and finish it in another.
				! endif
				! for key in data:
					## do something with key in here
				! endfor
				$ 'an expression'.title()
				Or perhaps an ${'inline'.upper()} expression?				
				## comment
				
				%img{'src':'/whatever.jpg'}


script to auto-set the proper permissions for suexec on our server
	looks in the conf/httpd.include for the
	"SuexecUserGroup         mikeboers psacln" line to tell it what user/group
	we need to run as
	
	check `id -Gn apache` to see if psasrv is there... then we know we are on
	the vps
	
	or check the hostname...

beta. and stage. should have a whitelist to allow entry. that whitelist should
be able to be added to from the web with a password or by visiting some signed URL

