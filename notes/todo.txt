
- convert init_request and request_finished to Events


- remove beaker extensions (not used)
- remove serve extensions (just write your own...)
- remove unicode (should be handled by Response)
- remove api
	- add Request.assert_args(*names) -> throws an exception if it doesn't have them
	- rewrite CRUD
- move flash messages to session AppMixin
- remove headers (werkzeugs are good)
- remove pager
- rename to seekable_body and Request.make_body_seekable
- rename db to sqlalchemy
	- remove session extensions
	- remove declarative extensions
- remove HTTP prefixed exceptions
- rename files to static
- rename forms to wtforms
- remove uri
	- move signing to nitrogen.sign
	- keep encode/decode
	- keep parse/format
	- keep remove_dot_segments
	- keep resolve_relative
	- keep query_encode/decode
- remove most of crypto (replaced by pytomcrypt)



- webstar.Router.__call__ should move most of it's functionality to a helper
  method which takes what it wants from the environment and returns the route,
  etc.. Then nitrogen will use that instead of calling the router directly.
  This will allow us to check __acl__ attributes on the entire route, and we
  can pass nitrogen.request.Request objects directly. All of the wsgi-style
  middleware can be applied around this call_app method.
	- determine if there is ever any other wsgi-style middleware applied
	  directly to actions
	- @wsgi_middleware(func)
		creates a __wsgi_stack__ attribute on the function which is what would
		actually be called by nitrogen if it was present
	- the request should have a response attribute created on it, which will
	  be the response object that renderers will use

- @renderer(html='/path/to/template')
	- requesting something.json would give us the JSON dump
	- requesting something.html would give us the rendered page
	- anything else would default to the rendered page

- nitrogen.util.deprecated
	- log the usage just once per process

- some way to convert data to json format if requested, otherwise actually
  render everything. Will need to be sure that there aren't any secret things
  being passed to the templates...

- upgrade to Werkzeug 0.7

- werkzeug tracks all of the amounts posted, we dont need to at request.py:143
	I think we may still need to.

- constructive things to do
	- plugin architecture and/or namespaces for app plugins
	- new authentication system that works with new routers
	- AuthMixin based off of st5 extensions to App
	- ImgSizer that uses x_sendfile
		- Some base class for generating content that gets saves into files.

- Response.from_static_file(path, use_x_sendfile=True)
	- set last_modified to mtime of file

- FileMutator
	- a couple of methods to override to have a file served that is built from
	  another. the results will be cached

- versioned_static_url('/path/to/asset')
	- makes a '/t=<mtime-of-file>/path/to/asset?v=<mtime-of-file>'
	- these should be served with a HUGE cache time

- nitrogen.sign
	- sign(secret, str_to_sign, **kwargs) -> signature
	- verify(secret, str_to_sign, signature, **kwargs) -> bool
	
	- either use a deterministic repr or only allow strings to be signed
	
- deprecate some Request properties

- nitrogen.lock.FileLock
	__init__(path, mode='shared', recursive=False)
	acquire
	locked
	release
	upgrade -> convert shared to exclusive
	downgrade -> convert exclusive to shared






- consider moving Cookie signing code into the cookies themselves, and the
  container has a list of classes to use to try to parse the raw values

- new session	
	- __ctime__, __atime__, __mtime__ in the dict
	- .lock(name='__main__', shared=False) method creates a /<root>/<id>.<name>.lock file and returns it
	- .purge/.reset/.clear/.save methods
	- the dict must detect mutations
	- save by writing to /<root>/<name>.<random>.journal and moving into place
		this avoids a race condition



- instead of naming app mixin classes ResponseMixin, perhaps have a decorator
which marks something as a mixin.
	
	@mixin('Response')
	class ResponseMixin(object):
		pass


- consider using venusian
- remove all the packages that were there for b/c
    - record them as we go so we can have something to rewrite it
- replace as much of werkzeug as we can with paste/webob
    - go back to the monkey patched cgi.FieldStorage
        - perhaps make this it's own project?
        - parse_(query|form|files) caches the NON decoded version in the environ
            parse_query(environ, charset=None) -> non decoded
            parse_query(environ, charset='utf8') -> decoded
    - OR strip werkzeugs out

- pyramid.decorator.reify is pretty awesome

- replace webhelpers with lxml

- Authnz package could provide a router object which tests ACLs
- authn is extracting principals (uid and gid) from a request
- authz is determining if principals are ALLOWed or DENYied by an __acl__
- Pyramid authn_policy interface only supplies:
    - unauthenticated_userid(self, request)
    - remember(self, request, principal, **kw)
    - forget(self, request)

- should the things that AppMixins export be namespaced? Instead of exporting
  everything they could export a single object such as "db" with all the DB
  stuff

- AppPlugin instead of AppMixin
	- use c3linearize to determine proper ordering of plugins

    
- perhaps absolute uri.path.Path should have an empty first element, or a '/'
  first element. It seems more sensible that it be an empty first element

- move mako stuff into nitrogen.templates.mako.helpers

- Pyramid renderers are rather nice.
    @Request.application # or @Request.wrap
    @renderer('template.html.mako') # run through MakoRenderer and then HTMLRenderer (which sets the mimetype)
    def something(req):
        return {'key': 'value'}

- asset specification is nice: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/assets.html#asset-specifications

- consider moving to an events-like notification system for the before_request and after_request sort of callbacks.

- my authorization system should use the __acl__ instance and class properties (building the full ACL from the entire mro of the object).
    - principals could be "mikeboers", "role:admin" and "group:users"
    - OR "username" and "@group" and "+role"
        - these ones mean there is nothing actually special about the principals; they are all handled the same
    - we calculate the full ACL as the merge of the __acl__ parameters along the MRO of the object.
        - we can provide an __acl_bases__ which is used instead of __class__.__bases__ in the C3 (ie. mro) algo.

- use this new linearizer for the building of classes out of mixins on the AppMixins

- take a good hard look at some sort of plugin architechture or the ZCA (Zope Component Architecture) instead of multiple inheritance for linking all of the App pieces together.
    - where there are dependencies, the individual plugins can define what they need, and what they use
    - the c3linearize could be used to figure out an assembly order of these
    - the plugin api should be as minimal as possible:
        - method to return list of middleware
        - method to return dict of what should be exported to globals
        - method to setup configuration defaults
        
- have to look really hard at the "context" resource that Pyramid is always talking about.

- consider putting the full python virtualenv into an env subdirectory in all of the sites. This may make everything a little bit more self contained and easier to work in.

- take a look at how pyramid tests itself


- API error handler is not printing out the environment of the request. Can we possibly extend logging to add this to the exception method, or perhaps add a wsgi_exception method?

- pull sign/verify off of query object and into the crypto module
- transform query into a general map serializer
- turn uri.path into a simpler string?

- remove all the werkzeug locals




- remove all of the wsgi wrappers; they are unnessesary

- consider swapping from Werkzeug request/response to webob
    - make_body_seekable is nice
    - the MultiDict works like mine does (and there are interesting variations)
    - urlargs/urlvars are interesting
    - pathinfo_pop/peek are interesting
    - aceept classes look cleaner
    - cookies are cleaner, but mine is more functional (ie. signed cookies)
    - post is NOT nice because cgi.FieldStorage does not have a maximum
		(surely it does though...)

- go back to a patched cgi.FieldStorage for the parsing instead of wz
    - need to provide max_memory, max_file_size, etc
	- theoretically Content-Length is the max around the cgi.fieldstorage
	  would read anyways, so we can simply reject based on that number

- remove all of the wsgi runners
- split proxy module into it's own package
- split route into pystar package
- remove the API module

- split cookies into their own package (or look at webob's)
- remove lipsum
- remove pager into it's own package

- rename nitrogen.db to nitrogen.sqla

- pull the mixin class builder into a package of its own?


- webob.exc is very nice

- add getone (and others) from webob.multidict to MultiMap



      
- send a 413 Request Entity Too Large for when limits are exceeded

- pkgutil: figure out how to split up the project
    1) namespaced_packages=[...] (i think) in setup.py. this may only be nessesary
       for installed packages, but may not be nesseary at all
    2) __import__('pkg_resources').declare_namespace(__name__) in all the
       __init__.py that are namespaced
    2-b) Could potentially use the pkgutil one as well:
        __path__ = __import__('pkgutil').extend_path(__path__, __name__)
        
    

- instead of using submodules I could have a pip requirements file that is
  only going off of the "editing" modules. `make freeze-subs` could

- http.status exceptions should NOT have HTTP prefix as they module chain has
  the "http" in there already.

- seperate uri package into it's own project

    - need to make the path classes make sense; perhaps the path should become
      immutable. you could slice it, and slicing off the front results in you
      loosing the absoluteness. a uri.path.join could be used to join stuff
      together with the same symantics as the os.path.join (use unixpath.join)
      
        >>> from urlparse import urlparse
        >>> urlparse('http://example.com').path
        ''
        >>> urlparse('http://example.com/').path
        '/'
        >>> urlparse('/absolute/path').path
        '/absolute/path'
        >>> urlparse('relative/path').path
        'relative/path'
        
        - perhaps absolute/relative could be an immutable property of a path
          object
        - perhaps the whole thing could be immutable, and we have some extra
          methods on it for path-related functions
            - segment(0) for the first segment
            - slice(...) for slicing up
            
            - is_relative if it is relative
            - is_absolute if it is absolute
            - pop(0) returns the first segment and then the rest
            - normalize() returns it with dot segments removed
    
    - can use urllib.quote(x, '~') as the encoding engine
        
    
    - query to_string and from_string should take the separator and setter as
      arguments:
        Query({a: 1, b:2}).to_string(',', ':', sorted=True) -> 'a:1,b:2'
    
    - the path and userinfo are both used so infrequently. perhaps they can both
      just be strings with some support functions for manipulating them
	
	- determine for sure when + is used instead of %20
		- it seems to be that + is in the query and %20 is in the path. a + in
		  the path is actually a +. i actually have to deal with this too as
		  application/www-form-encoded does encode spaces as +
		- firefox encodes a space as "+" when submitting a form with the GET
		  method. same for posted app/www-form-encoded (ie. no files)
		
	- determine if unicode characters are always encoded as utf8
		- it seems that application/www-form-encoded implies UTF8 encoding (at
		least that is what firefox does, even when it's Accept-Encoding does
		not prefer utf8)
		- same thing with the query string
	- write the encoding functions that go to %u#### and %U########
		- if there is ANY %u or %U in there, then %## is codepoints, not bytes
		- everything already works just fine with utf8 encoding; don't need
		  to mess with something that was rejected by the w3c
	
	- I should likely just accept that my library is for urls not uris
	
	- paste.request.path_info_split could be used

      
