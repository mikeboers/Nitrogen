
- pick an API for websockets

	1: something on top of raw wsgi
		def do_socket(environ, start):
			socket = get_websocket(environ, start)
			if not socket:
				request = Request(environ)
				return Response('something')
			msg = socket.recv()
			socket.send('whatever')
			
	2: something on top of Request
		def do_socket(request):
			socket = request.websocket
			if socket:
				msg = socket.recv()
				socket.send('whatever')
			else:
				return Response('not a socket')
		
		- Request.application would have to not return anything
		- there is a magical step where the connection is upgraded
	
	3: something on top of Response
		def do_socket(request):
			if request.upgrade == 'websocket':
			OR
			if request.is_websocket
				def _do_socket(socket):
					msg = socket.recv()
					socket.send('whatever')
				return WebSocketHandler(_do_socket)
		
		- the handler would need:
			- .status_code != 200
			- .__call__(self, environ, start)
				- negotiates the upgrade
				- creates the WebSocket object with send/recv
				- somehow hands the websocket to the app
				- runs the app
				- interprets the response from the app
		
		def do_socket(environ, start):
			def _do_socket(sock):
				pass
			return websocket.Response(_do_socket)(environ, start)

- eventsource API could mimic WebSocket:
	def do_eventstream(request):
		if request.is_eventstream:
			def _events():
				yield 1
				yield 'something'
				yield eventstream.Retry(10)
				yield eventstream.Event('something', id=12, retry=60, name='whatever')
			return eventstream.Response(_events())
		else:
			pass
	- replace Response.iter_encoded(self, charset=None):
		for item in self.response:
			- format it into an event
			- yield


- etags should also include headers which affect the agent's interpretation of the content, such as content-type

- instead of naming app mixin classes ResponseMixin, perhaps have a decorator
which marks something as a mixin.
	
	@mixin('Response')
	class ResponseMixin(object):
		pass

- AppPlugin instead of AppMixin
	- use c3linearize to determine proper ordering of plugins
	- they can be exposed as a namespace on the app object
	- they can be scanned for decorated Mixins
	- they can be scanned for decorated event handlers

- static_version('/path/to/file.js') should return /path/to/file.js?v=<mtime>
    - the v could be detected and force an infinite cache time

- WebStar could handle extensions:
    @route('/something', extensions=True) # wildcard extensions
    @route('/something', extensions=(None, 'json')) # nothing, or .json
    - just a string could either force that extension, or allow for no extension
    - they appear under the key 'extension'
    - generating a URL with 'extension' will only apply to the last segment
        - all formatters should ignore 'extension'
        - the primary generator handles this

- PyMemoize should be able to "expire" a value instead of deleting it
    - this would allow for returning the old value if an exception was
      thrown while calculating the new one

- SASS at runtime
    http://dev.ufsoft.org/projects/sass/repository/revisions/master/entry/flaskext/sass.py

- Javascript compression via uglify.js
    - similar setup to sass
    - config file has list of source files to minify/concat in order
    - `python setup.py js --watch`
    - `python setup.py css --watch`



- wtforms date and datetime should use input type="date"
  - same with email
- wtforms should be able to have placeholders


- asset specification -> "package.name:file_name.txt"


- remove pager
- rename forms to wtforms

- remove most of crypto (replaced by pytomcrypt)

- move mako stuff into nitrogen.templates.mako.helpers

- @renderer(html='/path/to/template')
	- requesting something.json would give us the JSON dump
	- requesting something.html would give us the rendered page
	- anything else would default to the rendered page

- some way to convert data to json format if requested, otherwise actually
  render everything. Will need to be sure that there aren't any secret things
  being passed to the templates...

- upgrade to Werkzeug 0.7



- FileMutator
	- a couple of methods to override to have a file served that is built from
	  another. the results will be cached

- versioned_static_url('/path/to/asset')
	- makes a '/t=<mtime-of-file>/path/to/asset?v=<mtime-of-file>'
	- these should be served with a HUGE cache time

- nitrogen.sign
	- sign(secret, str_to_sign, **kwargs) -> signature
	- verify(secret, str_to_sign, signature, **kwargs) -> bool
	
	- either use a deterministic repr or only allow strings to be signed


- nitrogen.lock.FileLock
	__init__(path, mode='shared', recursive=False)
	acquire
	locked
	release
	upgrade -> convert shared to exclusive
	downgrade -> convert exclusive to shared






- consider moving Cookie signing code into the cookies themselves, and the
  container has a list of classes to use to try to parse the raw values

- new session	
	- __ctime__, __atime__, __mtime__ in the dict
	- .lock(name='__main__', shared=False) method creates a /<root>/<id>.<name>.lock file and returns it
	- .purge/.reset/.clear/.save methods
	- the dict must detect mutations
	- save by writing to /<root>/<name>.<random>.journal and moving into place
		this avoids a race condition






- replace webhelpers with lxml

- Authnz package could provide a router object which tests ACLs
- authn is extracting principals (uid and gid) from a request
- authz is determining if principals are ALLOWed or DENYied by an __acl__
- Pyramid authn_policy interface only supplies:
    - unauthenticated_userid(self, request)
    - remember(self, request, principal, **kw)
    - forget(self, request)

- should the things that AppMixins export be namespaced? Instead of exporting
  everything they could export a single object such as "db" with all the DB
  stuff




- Pyramid renderers are rather nice.
    @Request.application # or @Request.wrap
    @renderer('template.html.mako') # run through MakoRenderer and then HTMLRenderer (which sets the mimetype)
    def something(req):
        return {'key': 'value'}

- asset specification is nice: http://docs.pylonsproject.org/projects/pyramid/1.0/narr/assets.html#asset-specifications

- use this new linearizer for the building of classes out of mixins on the AppMixins

- take a good hard look at some sort of plugin architechture or the ZCA (Zope Component Architecture) instead of multiple inheritance for linking all of the App pieces together.
    - where there are dependencies, the individual plugins can define what they need, and what they use
    - the c3linearize could be used to figure out an assembly order of these
    - the plugin api should be as minimal as possible:
        - method to return list of middleware
        - method to return dict of what should be exported to globals
        - method to setup configuration defaults
        
- have to look really hard at the "context" resource that Pyramid is always talking about.

- consider putting the full python virtualenv into an env subdirectory in all of the sites. This may make everything a little bit more self contained and easier to work in.

- take a look at how pyramid tests itself

- API error handler is not printing out the environment of the request. Can we possibly extend logging to add this to the exception method, or perhaps add a wsgi_exception method?

- pull the mixin class builder into a package of its own?

- pkgutil: figure out how to split up the project
    1) namespaced_packages=[...] (i think) in setup.py. this may only be nessesary
       for installed packages, but may not be nesseary at all
    2) __import__('pkg_resources').declare_namespace(__name__) in all the
       __init__.py that are namespaced
    2-b) Could potentially use the pkgutil one as well:
        __path__ = __import__('pkgutil').extend_path(__path__, __name__)
        
    

- instead of using submodules I could have a pip requirements file that is
  only going off of the "editing" modules. `make freeze-subs` could


      
